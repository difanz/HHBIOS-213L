;	READSL.ASM(L)
;	1997.6.28
;	1998.8.20
;	1999.11.26

FONTNUMBER	EQU	34
_DKXWS		EQU	2
IDX_MAX 	EQU	8000
FIX_LPS 	EQU	48
WORD_SIZE	EQU	256			; DOT (BIGGEST SIZE)
D_HZKSL 	EQU	88H			;矢量字库文件名安装地址

CSEG		SEGMENT
		ASSUME	CS:CSEG, DS:CSEG

		ORG	100H
START:		JMP	BEGIN

		ORG	1D0H
SET_PATH	DB	40 DUP(0)		;路径
SET_NAME	DW	0			;字库文件名写入地址
D_HANDLE	DW	0			;文件号

		ORG	200H
K_W		DB	0			;='W':文件方式
WDTH		DW	0			;字符宽度(AX)
FNUM		DW	0			;字体号/字库号(BX)
HIGHT		DW	0			;字符高度(CX)
D_DX		DW	0			;汉字内码(DX)
STARTLINE	DW	0			;起始行(SI)
ENDLINE 	DW	0			;终止行(DI)

;各字库原点阵表------------
DH_TBASE	DW	128
DH_STJBASE	DW	96
DH_FSJBASE	DW	96
DH_HTJBASE	DW	96
DH_KTJBASE	DW	96
DH_XBJBASE	DW	96
DH_BSJBASE	DW	96
DH_Y1JBASE	DW	128
DH_Y3JBASE	DW	128
DH_LBJBASE	DW	128
DH_DHJBASE	DW	128
DH_WBJBASE	DW	128
DH_XKJBASE	DW	128
DH_LSFBASE	DW	128
DH_YTJBASE	DW	128
DH_MHJBASE	DW	128

DH_111BASE	DW	96
DH_222BASE	DW	96
DH_333BASE	DW	96
DH_444BASE	DW	96
DH_555BASE	DW	96

DH_STFBASE	DW	96
DH_FSFBASE	DW	96
DH_HTFBASE	DW	96
DH_KTFBASE	DW	96
DH_XBFBASE	DW	96
DH_XLFBASE	DW	96
DH_Y1FBASE	DW	256
DH_Y3FBASE	DW	256
DH_LBFBASE	DW	256
DH_DHFBASE	DW	256
DH_WBFBASE	DW	256
DH_XKFBASE	DW	128
DH_HPFBASE	DW	256
DH_ZYFBASE	DW	256

;各字库连续块表地址(READSL=1有,=0无)
DH_T		DW	0			;HZKSLT
DH_STJ		DW	0			;HZKSLSTJ
DH_FSJ		DW	0			;HZKSLFSJ
DH_HTJ		DW	0			;HZKSLHTJ
DH_KTJ		DW	0			;HZKSLKTJ
DH_XBJ		DW	0			;HZKSLXBJ
DH_BSJ		DW	0			;HZKSLBSJ
DH_Y1J		DW	0			;HZKSLY1J
DH_Y3J		DW	0			;HZKSLY3J
DH_LBJ		DW	0			;HZKSLLBJ
DH_DHJ		DW	0			;HZKSLDHJ
DH_WBJ		DW	0			;HZKSLWBJ
DH_XKJ		DW	0			;HZKSLXKJ
DH_LSJ		DW	0			;HZKSLLSJ
DH_YTJ		DW	0			;HZKSLYTJ
DH_MHJ		DW	0			;HZKSLMHJ

DH_111		DW	0			;
DH_222		DW	0			;
DH_333		DW	0			;
DH_444		DW	0			;
DH_555		DW	0			;

DH_STF		DW	0			;HZKSLSTF
DH_FSF		DW	0			;HZKSLFSF
DH_HTF		DW	0			;HZKSLHTF
DH_KTF		DW	0			;HZKSLKTF
DH_XBF		DW	0			;HZKSLXBF
DH_XLF		DW	0			;HZKSLXLF
DH_Y1F		DW	0			;HZKSLY1F
DH_Y3F		DW	0			;HZKSLY3F
DH_LBF		DW	0			;HZKSLLBF
DH_DHF		DW	0			;HZKSLDHF
DH_WBF		DW	0			;HZKSLWBF
DH_XKF		DW	0			;HZKSLXKF
DH_HPF		DW	0			;HZKSLHPF
DH_ZYF		DW	0			;HZKSLZYF

LPS_WORD	DW	0
LPS_DX		DW	0
WDTH_WORD	DW	0
_WDTH		DW	0
BSIZE		DW	0			;样本字符大小
WBSIZE		DW	0			;旋转西文时用的样本字符大小
SLIP_LEN	DW	0

;中断7EH入口 ----------------------------------------------------------------
;读取字模点阵(包括汉字及西文)
;入口参数:
;	DX	汉字内码 若高字节为 0 则低字节为ASCII码
;		若 DX=0 则返回 DX:BX 指向一个长度为 3,328 BYTEs 的空闲缓冲区
;	AX	字符宽度
;	CX	字符高度
;	BX	字体编号(西文为0:等宽)
;	SI	起始还原行
;	DI	终止还原行
;	BP	第 15 位 =0 不旋转	=1 字符旋转
;		第 14 位 =0 向左旋转	=1 向右旋转
;		第 13 位 =0 旋转  90 度 =1 旋转 180 度
;		第 12 位 =0 非上下标	=1 上标
;		第 11 位 =0 非上下标	=1 下标
;		第  0 位 =0 水平点阵	=1 垂直点阵
;返回参数:
;	DX:BX	点阵缓冲区地址指针
;	AX	字符实际宽度
;	CX	字符实际高度

		DB	'SL'                    ;驻留标志
INT_7E		PROC	FAR
		STI
		CLD
		OR	DX,DX			;=0: 取缓冲区地址DX:BX
		JNZ	L_10
		MOV	DX,CS
		MOV	BX,OFFSET D_BUF2
		MOV	AX,OFFSET DH_STJ	;11.15
		IRET
L_10:
		PUSH	DS
		PUSH	ES
		PUSH	CS
		POP	DS
		PUSH	CS
		POP	ES

		OR	AX,AX			;判宽度=0?
		JNZ	L_20
		JMP	L_102
L_20:
		OR	CX,CX			;判高度=0?
		JNZ	L_30
		JMP	L_102
L_30:
		TEST	BP,1800H
		JZ	L_40
		SHR	AX,1			;上下标
L_40:
		MOV	WDTH,AX 		;存宽度
		MOV	FNUM,BX 		;存字体号
		MOV	HIGHT,CX		;存高度
		MOV	D_DX,AX 		;存汉字内码
		MOV	STARTLINE,SI		;存起始行
		MOV	ENDLINE,DI		;存终止行

		OR	DH,DH			;判字符?
		JNZ	L_50
		JMP	L_70
L_50:
		AND	DX,7F7FH
		SUB	DX,2121H
		MOV	AL,DH			;AX=区号
		MOV	CL,DL			;CX=位号
		XOR	CH,CH
		CMP	DH,15			;判汉字?
		JB	L_60
		SUB	AL,15
		ADD	FNUM,1			;汉字:宋体=1...
		JMP	SHORT L_62
L_60:
		MOV	FNUM,0			;字符=0
L_62:
		MOV	BX,FNUM
		CMP	BX,FONTNUMBER		;判字体号超?
		JA	L_66
		MOV	SI,BX
		SHL	SI,1
		MOV	SI,DH_TBASE[SI] 	;字库索引区
		MOV	BSIZE,SI
		MOV	WBSIZE,SI

		MOV	AH,94
		MUL	AH			;区号*94
		ADD	AX,CX			;+位号, AX=序号
		CALL	READZK			;读字库
		JC	L_66
		CALL	ENLARGE
		JMP	L_98
L_66:
		MOV	WORD PTR D_BUF3,0	;返回空点阵
		JMP	L_98

L_70:
		CMP	BX,_DKXWS
		JB	L_74
		MOV	FNUM,0
L_74:
		MOV	AX,DH_TBASE
		MOV	BSIZE,AX
		SHR	AX,1
		MOV	WBSIZE,AX

		CMP	DL,' '
		JNZ	L_80
		MOV	SLIP_LEN,0
		MOV	WORD PTR D_BUF2,0
		JMP	L_92
L_80:
		SUB	DL,21H
		MOV	CX,DX
		MOV	AX,FNUM
		MOV	DX,94
		MUL	DX
		ADD	AX,9*94
		ADD	AX,CX
		MOV	FNUM,0

		PUSH	AX
		MOV	AX,DH_TBASE
		MOV	BSIZE,AX
		MOV	AX,BSIZE
		SHR	AX,1
		MOV	WBSIZE,AX
		POP	AX

		CMP	CL,'~'
		JA	L_94
		CALL	READZK			;读字库
		JC	L_94
L_92:
		CALL	ENLARGE
		JMP	SHORT L_96
L_94:
		MOV	WORD PTR D_BUF3,0
L_96:
		TEST	BP,8000H
		JNZ	L_98
		XOR	DX,DX
		MOV	AX,WDTH
		SHR	AX,1
		MOV	WDTH,AX
L_98:
		MOV	AX,WDTH
		ADD	AX,7
		SHR	AX,1
		SHR	AX,1
		SHR	AX,1
		MOV	SI,OFFSET D_BUF3
		MOV	BX,ENDLINE
		SUB	BX,STARTLINE
		MOV	LPS,BX
		MOV	BX,STARTLINE
		PUSH	BP
		MOV	BP,1
		CALL	WORD_PROCESS
		POP	BP
		TEST	BP,1
		JZ	L_99
		CALL	HORITOVERT
L_99:
		MOV	AX,WDTH
		MOV	CX,HIGHT

		TEST	BP,1			;垂直点阵?
		JNZ	L_100
		MOV	BX,OFFSET D_BUF2
		JMP	SHORT L_101
L_100:
		MOV	BX,OFFSET D_BUF3
L_101:
		MOV	DX,DS
L_102:
		POP	ES
		POP	DS
		IRET
INT_7E		ENDP

;华夏矢量字库矢量释放模块
;------------------------------------------------------------------------------
;标记字节:
;	7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
;	\_/ \___________/ \___________/ 	多边形开始
;	1 1	  x		y
;------------------------------------------------------------------------------
;	7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
;	\_/ \_________/ \_____/ \_____/ 	后跟N个dx,dy 第7位,第3位 = 0 正
;	0 0	  N	  dx	   dy					 = 1 负
;------------------------------------------------------------------------------
;	7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
;	\_/ \_/ \_____/ \_____/ \_____/ 	后跟N个在同一象限内的 dx,dy
;	0 1 象限   N	  dx	   dy
;------------------------------------------------------------------------------
;	7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
;	\_/ \_/ \_____/ \_____________/ 	dx,dy中至少有一个大于16
;	1 0 0 0   dx	      dy		dy>16
;	    0 1   dy	      dx		dx>16
;------------------------------------------------------------------------------
;	7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0 7 6 5 4 3 2 1 0
;	\_/ \_/ 	\_____________/ \_____________/ 	dx>16,dy>16
;	1 0 1 1 	      dx	       dy
;------------------------------------------------------------------------------
;入口参数:
;	ds:si	压缩的矢量信息缓冲区地址
;	cx	压缩的矢量信息缓冲区长度
;	es:di	释放出的矢量缓冲区地址

DOT_COUNT	DW	0
POLYSTART	DW	0

MELTE		PROC	NEAR
		PUSH	BP
		CLD
		MOV	BX,CX
		MOV	SLIP_LEN,0
		MOV	POLYSTART,DI
		MOV	DOT_COUNT,0
_MELTE_:
		LODSB
		DEC	BX

		TEST	AL,80H
		JZ	_MELTE_L1
		TEST	AL,40H
		JNZ	_MELTE_L5
		JMP	_MELTE_L2
_MELTE_L5:					;11000000B
		PUSH	AX
		PUSH	BX
		MOV	BX,POLYSTART
		MOV	AX,DOT_COUNT
		MOV	WORD PTR [BX],AX
		MOV	POLYSTART,DI
		SHL	AX,1
		ADD	AX,SLIP_LEN
		ADD	AX,2
		MOV	SLIP_LEN,AX
		INC	DI
		INC	DI
		POP	BX
		POP	AX
		MOV	DOT_COUNT,0

		MOV	AH,AL
		LODSB
		DEC	BX
		AND	AH,3FH
		SHL	AX,1
		SHR	AL,1
		XCHG	AH,AL
		MOV	DX,AX			;DL=X, DH=Y
		JMP	_STORE_POINT
_MELTE_L1:
		TEST	AL,40H
		JNZ	_MELTE_L4
		JMP	_MELTE_L3
_MELTE_L4:					;01000000B
		XOR	AH,AH
		MOV	BP,AX
		AND	BP,30H
		AND	AL,0FH
		XOR	CX,CX
		MOV	CL,AL
		ADD	DOT_COUNT,CX
_MELTE_CASE_1:
		LODSB
		DEC	BX
		MOV	AH,AL
		AND	AH,0FH
		SHR	AL,1
		SHR	AL,1
		SHR	AL,1
		SHR	AL,1
		OR	BP,BP
		JZ	_AREA_1
		CMP	BP,10H
		JZ	_AREA_2
		CMP	BP,20H
		JZ	_AREA_3
_AREA_4:
		ADD	DL,AL
		SUB	DH,AH
		JMP	SHORT _STORE_P
_AREA_1:
		ADD	DL,AL
		ADD	DH,AH
		JMP	SHORT _STORE_P
_AREA_2:
		SUB	DL,AL
		ADD	DH,AH
		JMP	SHORT _STORE_P
_AREA_3:
		SUB	DL,AL
		SUB	DH,AH
_STORE_P:
		MOV	AX,DX
		STOSW
		LOOP	_MELTE_CASE_1
		JMP	_MELTE_LOOP
_MELTE_L2:					;10000000B
		XOR	AH,AH
		MOV	BP,AX
		AND	BP,30H
		OR	BP,BP
		JZ	_DY_G_16
		CMP	BP,10H
		JZ	_DX_G_16
		LODSB				;D_X>16,D_Y>16
		DEC	BX
		MOV	AH,AL
		LODSB
		DEC	BX
		XCHG	AH,AL
		TEST	AL,80H
		JZ	_ADD_3
		AND	AL,7FH
		SUB	DL,AL
		JMP	SHORT _OPERATE_Y_2
_ADD_3:
		ADD	DL,AL
_OPERATE_Y_2:
		TEST	AH,80H
		JZ	_ADD_4
		AND	AH,7FH
		SUB	DH,AH
		JMP	_STORE_POINT
_ADD_4:
		ADD	DH,AH
		JMP	_STORE_POINT
_DY_G_16:					;D_X<16, D_Y>16
		AND	AL,0FH
		MOV	AH,AL
		LODSB
		DEC	BX
		XCHG	AH,AL
		TEST	AL,08H
		JZ	_ADD_5
		AND	AL,07H
		SUB	DL,AL
		JMP	SHORT _OPERATE_Y_3
_ADD_5:
		ADD	DL,AL
_OPERATE_Y_3:
		TEST	AH,80H
		JZ	_ADD_6
		AND	AH,7FH
		SUB	DH,AH
		JMP	_STORE_POINT
_ADD_6:
		ADD	DH,AH
		JMP	_STORE_POINT
_DX_G_16:					;D_X>16, D_Y<16
		AND	AL,0FH
		MOV	AH,AL
		LODSB
		DEC	BX
		TEST	AL,80H
		JZ	_ADD_7
		AND	AL,7FH
		SUB	DL,AL
		JMP	SHORT _OPERATE_Y_4
_ADD_7:
		ADD	DL,AL
_OPERATE_Y_4:
		TEST	AH,08H
		JZ	_ADD_8
		AND	AH,07H
		SUB	DH,AH
		JMP	_STORE_POINT
_ADD_8:
		ADD	DH,AH
		JMP	_STORE_POINT
_MELTE_L3:					;00000000B
		AND	AX,003FH
		MOV	CX,AX
		ADD	DOT_COUNT,CX
_MELTE_CASE_0:
		LODSB
		DEC	BX
		MOV	AH,AL
		AND	AH,0FH
		SHR	AL,1
		SHR	AL,1
		SHR	AL,1
		SHR	AL,1
		TEST	AL,08H
		JZ	_ADD_1
		AND	AL,07H
		SUB	DL,AL
		JMP	SHORT _OPERATE_Y_1
_ADD_1:
		ADD	DL,AL
_OPERATE_Y_1:
		TEST	AH,08H
		JZ	_ADD_2
		AND	AH,07H
		SUB	DH,AH
		JMP	SHORT _OPERATE_FINISH
_ADD_2:
		ADD	DH,AH
_OPERATE_FINISH:
		MOV	AX,DX
		STOSW
		LOOP	_MELTE_CASE_0
		JMP	SHORT _MELTE_LOOP
_STORE_POINT:
		INC	DOT_COUNT
		MOV	AX,DX
		STOSW
_MELTE_LOOP:
		TEST	BX,0FFFFH
		JZ	_QUIT_MELTE
		JMP	_MELTE_
_QUIT_MELTE:
		XOR	AX,AX
		STOSW
		MOV	BX,POLYSTART
		MOV	AX,DOT_COUNT
		MOV	WORD PTR [BX],AX
		SHL	AX,1
		ADD	AX,SLIP_LEN
		MOV	SLIP_LEN,AX
		POP	BP
		RET
MELTE		ENDP

;子程序:字符矢量码变倍-------------------------------------------------------
;入口参数:
;	wdth	字符宽
;	hight	字符高
;	dot_buffer   原矢量码
;	arr	变倍后矢量码
;	bp	横纵点阵标志
VHIGHT		DW	0
_U_L_LINE_HI	DB	0

ENLARGE 	PROC	NEAR
		PUSH	DI
		PUSH	SI
		MOV	_U_L_LINE_HI,1
		TEST	BP,0001H
		JZ	_NOT_VERTBMP
		XOR	DX,DX
		MOV	AX,HIGHT
		MOV	CX,24
		DIV	CX
		MOV	VHIGHT,0
		OR	DX,DX
		JZ	_NOT_VERTBMP
		SUB	CX,DX
		MOV	VHIGHT,CX
_NOT_VERTBMP:
		TEST	BP,0400H	  ;上划线?
		JZ	_NOT_UPPER_LINE
		MOV	DI,OFFSET D_BUF2
		ADD	DI,SLIP_LEN
		MOV	AX,4
		STOSW
		MOV	AH,_U_L_LINE_HI
		MOV	AL,0
		STOSW
		MOV	AL,BYTE PTR WBSIZE
		DEC	AL
		STOSW
		MOV	AH,0
		STOSW
		XOR	AL,AL
		STOSW
		XOR	AX,AX
		STOSW
		MOV	AX,SLIP_LEN
		ADD	AX,10
		MOV	SLIP_LEN,AX
			;JMP	 _NOT_LOWER_LINE
_NOT_UPPER_LINE:
		TEST	BP,0200H	  ;下划线?
		JZ	_NOT_LOWER_LINE
		MOV	DI,OFFSET D_BUF2
		ADD	DI,SLIP_LEN
		MOV	AX,4
		STOSW
		MOV	AL,0
		MOV	AH,BYTE PTR BSIZE
		DEC	AH
		STOSW
		MOV	AL,BYTE PTR WBSIZE
		DEC	AL
		STOSW
		SUB	AH,_U_L_LINE_HI
		STOSW
		XOR	AL,AL
		STOSW
		XOR	AX,AX
		STOSW
		MOV	AX,SLIP_LEN
		ADD	AX,12
		MOV	SLIP_LEN,AX
_NOT_LOWER_LINE:
		MOV	SI,OFFSET D_BUF2
		MOV	DI,OFFSET D_BUF3
_ORDOR:
		LODSW
		OR	AX,AX
		JNZ	_GO_ORDOR
		JMP	_OUT_ENLARGE
_GO_ORDOR:
		STOSW
		MOV	CX,AX
_ENLARG:
		XOR	AX,AX
		LODSB			;LOAD X
		CMP	AX,BSIZE
		JB	_VALUE_OK1
		MOV	AX,BSIZE
		DEC	AX
_VALUE_OK1:
		PUSH	AX
		XOR	AX,AX
		LODSB			;LOAD Y
		CMP	AX,BSIZE
		JB	_VALUE_OK2
		MOV	AX,BSIZE
		DEC	AX
_VALUE_OK2:
		MOV	BX,AX		;BX=Y
		POP	AX		;AX=X

		TEST	BP,1000H
		JZ	_NOT_UPPER_FONT
		SHR	BX,1
		JMP	SHORT _NOT_LOWER_FONT
_NOT_UPPER_FONT:
		TEST	BP,0800H
		JZ	_NOT_LOWER_FONT
		SHR	BX,1
		MOV	DX,BSIZE
		SHR	DX,1
		ADD	BX,DX
_NOT_LOWER_FONT:

		TEST	BP,8000H
		JZ	_NO_ROTATE
		TEST	BP,4000H
		JZ	_ROT_LEFT
		TEST	BP,2000H
		JNZ	_ROT_180
		MOV	DX,BSIZE
		SUB	DX,BX
		DEC	DX
		MOV	BX,AX
		MOV	AX,DX
		MOV	DX,BSIZE
		SUB	DX,WBSIZE
		ADD	BX,DX
		JMP	SHORT _NO_ROTATE
_ROT_LEFT:
		TEST	BP,2000H
		JZ	_ROT_LEFT_90
_ROT_180:
		MOV	DX,BSIZE
		SUB	DX,BX
		DEC	DX
		MOV	BX,DX
		MOV	DX,WBSIZE
		SUB	DX,AX
		DEC	DX
		MOV	AX,DX
		JMP	SHORT _NO_ROTATE
_ROT_LEFT_90:
		MOV	DX,BSIZE
		SUB	DX,AX
		DEC	DX
		MOV	AX,BX
		MOV	BX,DX
_NO_ROTATE:
		PUSH	BX
		MOV	BX,WDTH
		MUL	BX
		MOV	BX,BSIZE
		DIV	BX
		STOSW

		POP	AX
		MOV	BX,HIGHT
		MUL	BX
		MOV	BX,BSIZE
		DIV	BX
		TEST	BP,0001H
		JZ	_NOT_VERTBMP1
		ADD	AX,VHIGHT
_NOT_VERTBMP1:
		STOSW
		DEC	CX
		JZ	_NEXT_POLY
		JMP	_ENLARG
_NEXT_POLY:
		JMP	_ORDOR
_OUT_ENLARGE:
		STOSW
		POP	DI
		POP	SI
		RET
ENLARGE 	ENDP

;子程序:wdth-----------------------------------------------------------------
;lps
;dot_buffer
;arr
HORITOVERT	PROC	NEAR
		XOR	DX,DX
		MOV	AX,LPS
		MOV	CX,8
		DIV	CX
		MOV	LPS_DX,DX
		MOV	LPS_WORD,AX

		MOV	CX,WDTH
		ADD	CX,7
		SHR	CX,1
		SHR	CX,1
		SHR	CX,1
		MOV	WDTH_WORD,CX

		MOV	SI,OFFSET D_BUF2
		MOV	DI,OFFSET D_BUF3
_HRTOVT:
		PUSH	CX
		MOV	CX,8
_ROTSHFT8R:
		PUSH	SI
		PUSH	CX
		MOV	DX,LPS_WORD
_ROTSHFTROW:
		OR	DX,DX
		JZ	_ROTSHFTLSTROW
		MOV	CX,8
		CALL	VERTCX
		INC	DI
		DEC	DX
		JMP	SHORT _ROTSHFTROW
_ROTSHFTLSTROW:
		MOV	CX,LPS_DX
		OR	CX,CX
		JZ	_NO_THIS_LINE
		CALL	VERTCX
		INC	DI
_NO_THIS_LINE:
		POP	CX
		POP	SI
		LOOP	_ROTSHFT8R
		INC	SI
		POP	CX
		LOOP	_HRTOVT
		RET
HORITOVERT	ENDP

;----------------------------------------------------------------------------
;ds:si=source buffer
;ds:di=target buffer
;cx=lines (<=8)
;wdth_word
VERTCX		PROC	NEAR
		OR	CX,CX
		JZ	_OUT_ROTSHFTL
		MOV	BX,CX
_ROTSHFTL:
		SHL	BYTE PTR [SI],1
		RCL	BYTE PTR [DI],1
		ADD	SI,WDTH_WORD
		LOOP	_ROTSHFTL
		MOV	CX,BX
		XCHG	CH,CL
		MOV	CL,8
		SUB	CL,CH
		JZ	_OUT_ROTSHFTL
		SHL	BYTE PTR [DI],CL
_OUT_ROTSHFTL:
		RET
VERTCX		ENDP

;============================================================================

BYTEORWORD	DW	0
LPS		DW	24
START_LINE	DW	0
WORD_WIDTH	DW	0
START_IN_SEG	DB	0
START_IN_SEG1	DB	0
TEMPX		DW	0
TEMPY		DW	0

; IN:  ds:  segment of slps of a word
;      si:  offset of slps of a word
;      ax:  word_width (unit is byte)
;      bx:  start_line
;      bp:  =0 : node size is byte;    =1 : node size is word;
; OUT: ds:  segment of dot martrix
;      si:  offset of dot martrix

WORD_PROCESS	PROC	NEAR
		PUSH	AX
		PUSH	BX
		PUSH	CX
		PUSH	DX
		PUSH	BP
		PUSH	DI
	;	PUSH	ES
	;	PUSH	CS
	;	POP	ES
		CLD
		MOV	WORD_WIDTH,AX
		MOV	START_LINE,BX
		MOV	BYTEORWORD,BP
		MOV	DI,OFFSET D_BUF1
		MOV	CX,WORD_SIZE/8*FIX_LPS
		XOR	AX,AX
		REP	STOSW
		MOV	DI,OFFSET D_BUF2
		MOV	CX,WORD_SIZE/8*FIX_LPS
		REP	STOSB
MPB:
	;	XOR	AX,AX
		LODSW		       ; UPDATA 6.19
		MOV	CX,AX
		CMP	CX,0
		JNZ	MMP0
		JMP	MP_QUIT
;
; THIS CODE USES FOR SLP IN ONE DOT
; WRITE ON 91.2.5
MMP0:
		PUSH	CX
		PUSH	SI
		CMP	BYTEORWORD,0
		JNZ	LJY01
		LODSB
		MOV	TEMPX,AX
		LODSB
		MOV	TEMPY,AX
		JMP	SHORT LJY02
LJY01:
		LODSW
		MOV	TEMPX,AX
		LODSW
		MOV	TEMPY,AX
LJY02:
		DEC	CX
MMP01:
		PUSH	CX
		MOV	BX,TEMPX
		MOV	DX,TEMPY
		CMP	BYTEORWORD,0
		JNZ	LJY03
		LODSB
		MOV	DI,AX
		LODSB
		JMP	SHORT LJY04
LJY03:
		LODSW
		MOV	DI,AX
		LODSW
LJY04:
		PUSH	SI
		MOV	SI,AX
		XCHG	SI,DI
		MOV	TEMPX,SI
		MOV	TEMPY,DI
		CALL	INSEG
		POP	SI
		POP	CX
		JNC	MMP02
		LOOP	MMP01
		POP	CX
		POP	CX
		JMP	MPB
MMP02:
		POP	SI
		POP	CX
MP0:
		CMP	BYTEORWORD,0
		JNZ	MP00
		LODSB
		MOV	BX,AX
		LODSB
		MOV	DX,AX
		JMP	SHORT MP000
MP00:
		LODSW
		MOV	BX,AX
		LODSW
		MOV	DX,AX
MP000:
		MOV	RESERVED_POINTX,BX
		MOV	RESERVED_POINTY,DX
		MOV	TEMPX,BX
		MOV	TEMPY,DX
		SUB	DX,START_LINE
		JS	MP10
		CMP	DX,LPS
		JNB	MP10
		MOV	START_IN_SEG,1
		MOV	START_IN_SEG1,1
MP10:
		DEC	CX
MP1:
		PUSH	CX
		MOV	BX,TEMPX
		MOV	DX,TEMPY
		XOR	AX,AX
		CMP	BYTEORWORD,0
		JNZ	MP00YH1
		LODSB
		JMP	SHORT MP00YH2
MP00YH1:
		LODSW
MP00YH2:
		MOV	DI,AX
		CMP	BYTEORWORD,0
		JNZ	MP00YH3
		LODSB
		JMP	SHORT MP00YH4
MP00YH3:
		LODSW
MP00YH4:
		PUSH	SI
		PUSH	DS
	;	PUSH	CS
	;	POP	DS
		MOV	SI,AX
		XCHG	SI,DI
		MOV	TEMPX,SI
		MOV	TEMPY,DI
		CALL	INSEG
		JB	MP2
		CALL	MAKE_SLP
MP2:
		POP	DS
		POP	SI
		POP	CX
		LOOP	MP1

	;	PUSH	DS
		PUSH	SI
	;	PUSH	CS
	;	POP	DS
		MOV	BX,TEMPX
		MOV	DX,TEMPY
		MOV	SI,RESERVED_POINTX
		MOV	DI,RESERVED_POINTY
		CALL	INSEG
		JC	MP31
		CALL	MAKE_SLP
MP31:
		CMP	START_IN_SEG,0
		JZ	MP3
		CALL	MAKE_END_POINT
MP3:
		POP	SI
	;	POP	DS
		MOV	START_IN_SEG,0
		MOV	START_IN_SEG1,0
		JMP	MPB
MP_QUIT:
		CALL	CHANGE_TO_DOT
	;	PUSH	CS
	;	POP	DS
		MOV	SI,OFFSET D_BUF2
	;	POP	ES
		POP	DI
		POP	BP
		POP	DX
		POP	CX
		POP	BX
		POP	AX
		RET
WORD_PROCESS	ENDP

; IN:	bx,dx:	slp start point X,Y
;	si,di:	slp end point X,Y
; OUT:	flags=CY  slp not in segment
;	bp: line type 1: x>=0 y<0    2: x<0  y<0
;		      3: x<0  y>=0   4: x>=0 y>=0
;		      bit 0: 1	y>=0	bit 1: 1 x>=0
;		      bit 2: 1	hori. line   bit 3: 1 vert. line
; CHANGE: ax,bp

INSEG		PROC	NEAR
		PUSH	BX
		PUSH	SI
		PUSH	DX
		PUSH	DI
		MOV	AX,START_LINE
		XOR	BP,BP
		SUB	DX,AX
		JS	I1
		CMP	DX,LPS
		JB	I2
		OR	BP,8000H       ; DOWN LINE
I1:
		SUB	DI,AX
		JS	I7
		CMP	DI,LPS
		JNB	I8
; IN SEGMENT
I2:
		POP	DI
		POP	DX
		PUSH	DX
		PUSH	DI
		SUB	DI,DX
		JNZ	I3
		OR	BP,100B 	 ; HORI. LINE
I3:
		JS	I4
		OR	BP,1		 ; Y>=0
I4:
		SUB	SI,BX
		JNZ	I5
		OR	BP,1000B	 ; VERT. LINE
I5:
		JS	I6
		OR	BP,10B		 ; X>=0
I6:
		AND	BP,1111B
		PUSH	BP
		AND	BP,1100B
		CMP	BP,1100B
		POP	BP
		JZ	IQ
		POP	DI
		POP	DX
		POP	SI
		POP	BX
		CLC
		RET
I7:
		TEST	BP,8000H
		JNZ	I2
		JMP	SHORT IQ
I8:
		TEST	BP,8000H
		JZ	I2
IQ:
		POP	DI
		POP	DX
		POP	SI
		POP	BX
		STC
		RET
INSEG		ENDP

;  IN:	bx,dx:	 start X,Y
;	si,di:	 end   X,Y
;	   bp:	 bit 0,1  line type
;  change: ax,cx
STATUS_BYTE	DB	0
DELTAX		DW	0
DELTAY		DW	0
DELTAX2 	DW	0

MAKE_SLP	PROC	NEAR
		TEST	BP,100B
		JNZ	HL
		TEST	BP,1000B
		JNZ	VL
		JMP	NORMAL
HL:
		MOV	AH,0
		CALL	MAKE_START_POINT
		MOV	AL,0
		OR	AX,BP
		AND	AL,11B
		MOV	CX,6
		SHL	AL,CL
		MOV	STATUS_BYTE,AL
		RET
VL:
		MOV	AH,100B
		CALL	MAKE_START_POINT
		SUB	DI,DX
		JS	VL1
VL0:
		DEC	DI
		JZ	VL2
		INC	DX
		MOV	AH,100B
		CALL	WRITE_2_BIT
		JMP	SHORT VL0
VL1:
		NEG	DI
VL3:
		DEC	DI
		JZ	VL2
		DEC	DX
		MOV	AH,100B
		CALL	WRITE_2_BIT
		JMP	SHORT VL3
VL2:
		RET
NORMAL:
		MOV	DELTAX,SI
		SUB	DELTAX,BX
		JNS	NR1
		NEG	DELTAX
NR1:
		MOV	DELTAY,DI
		SUB	DELTAY,DX
		JNS	NR2
		NEG	DELTAY
NR2:
		MOV	CX,DELTAX
		CMP	CX,DELTAY
		JB	TYPE_TWO
TYPE_ONE:
		INC	CX
		SHR	CX,1
		MOV	DELTAX2,CX
		SUB	SI,BX
		JNS	TO1
		NEG	SI
TO1:
		MOV	CX,DELTAY
		CMP	CX,DELTAX2
		JB	TO2
		PUSH	CX
		MOV	AH,100B
		CALL	MAKE_START_POINT
		MOV	AH,100B
		CALL	DIRE_ONE
		POP	CX
		SUB	CX,DELTAX
		JMP	SHORT TO3
TO2:
		PUSH	CX
		MOV	AH,0
		CALL	MAKE_START_POINT
		MOV	AH,0
		CALL	DIRE_ONE
		POP	CX
TO3:
		DEC	SI
		JZ	TOR
		ADD	CX,DELTAY
		TEST	CX,8000H
		JNZ	TO5
		CMP	CX,DELTAX2
		JB	TO5
		PUSH	CX
		MOV	AH,100B
		CALL	WRITE_2_BIT
		MOV	AH,100B
		CALL	DIRE_ONE
		POP	CX
		SUB	CX,DELTAX
		JMP	SHORT TO3
TO5:
		PUSH	CX
		MOV	AH,0
		CALL	WRITE_2_BIT
		MOV	AH,0
		CALL	DIRE_ONE
		POP	CX
		JMP	SHORT TO3
TOR:
		RET

;  WHEN DELTAY IS BIGGER THEN DELTAX DO THIS SUBROUNTIN
TYPE_TWO:
		MOV	CX,DELTAY
		XCHG	CX,DELTAX
		XCHG	DELTAY,CX
		INC	CX
		SHR	CX,1
		MOV	DELTAX2,CX
		SUB	DI,DX
		JNS	TW1
		NEG	DI
TW1:
		MOV	CX,DELTAY
		CMP	CX,DELTAX2
		JB	TW2		    ; X IS NOT CHANGE
		PUSH	CX
		MOV	AH,100B
		CALL	MAKE_START_POINT
		MOV	AH,100B
		CALL	DIRE_TWO
		POP	CX
		SUB	CX,DELTAX
		JMP	SHORT TW3
TW2:
		PUSH	CX
		MOV	AH,100B
		CALL	MAKE_START_POINT
		MOV	AH,0
		CALL	DIRE_TWO
		POP	CX
TW3:
		DEC	DI
		JZ	TWR
		ADD	CX,DELTAY
		TEST	CX,8000H
		JNZ	TW5
		CMP	CX,DELTAX2
		JB	TW5
		PUSH	CX
		MOV	AH,100B 	    ; X IS CHANGED
		CALL	WRITE_2_BIT
		MOV	AH,100B
		CALL	DIRE_TWO
		POP	CX
		SUB	CX,DELTAX
		JMP	SHORT TW3
TW5:
		PUSH	CX
		MOV	AH,100B 	    ; X IS NOT CHANGED
		CALL	WRITE_2_BIT
		MOV	AH,0
		CALL	DIRE_TWO
		POP	CX
		JMP	SHORT TW3
TWR:
		RET
MAKE_SLP	ENDP


; THIS SUBROUNTIN IS USED TO CHANGE BX AND DX WHEN ONE STEP FINISH
DIRE_ONE	PROC	NEAR
		TEST	BP,10B
		JZ	DO1	    ; DIRE 2 AND 3
		INC	BX
		JMP	SHORT DO2
DO1:
		DEC	BX
DO2:
		TEST	AH,100B
		JZ	DOR	    ; Y IS NOT CHANGE
		TEST	BP,1
		JZ	DO3	    ; DIRE 1 AND 2
		INC	DX
		RET
DO3:
		DEC	DX
DOR:
		RET
DIRE_ONE	ENDP

DIRE_TWO	PROC	NEAR
		TEST	BP,1
		JZ	DT1	    ; DIRE 1 AND 2
		INC	DX
		JMP	SHORT DT2
DT1:
		DEC	DX
DT2:
		TEST	AH,100B
		JZ	DTR	    ; X IS NOT CHANGE
		TEST	BP,10B
		JZ	DT3	    ; DIRE 2 AND 3
		INC	BX
		RET
DT3:
		DEC	BX
DTR:
		RET
DIRE_TWO	ENDP

; this subrountin is used to make start point of each slp
RESERVED_POINTX 	DW	0
RESERVED_POINTY 	DW	0
RESERVED_STATUS 	DB	0

MAKE_START_POINT  PROC	NEAR
		CMP	START_IN_SEG1,1
		JNZ	MS1
		MOV	RESERVED_POINTX,BX
		MOV	RESERVED_POINTY,DX
		MOV	AL,0
		OR	AX,BP
		AND	AL,11B
		MOV	CX,4
		SHL	AL,CL
		OR	AH,AL
		SHL	AL,1
		SHL	AL,1
		OR	AH,AL
		MOV	AL,AH
		MOV	RESERVED_STATUS,AL
		MOV	STATUS_BYTE,AL
		MOV	START_IN_SEG1,0
		RET
MS1:
		MOV	AL,0
		OR	AX,BP
		AND	AL,11B
		MOV	CX,4
		SHL	AL,CL
		PUSH	AX
		AND	STATUS_BYTE,11001111B
		OR	STATUS_BYTE,AL
		CALL	WRITE_2_BIT
		POP	AX
		SHL	AL,1
		SHL	AL,1
		AND	STATUS_BYTE,111111B
		OR	STATUS_BYTE,AL
		RET
MAKE_START_POINT ENDP

MAKE_END_POINT	PROC	NEAR
		MOV	BX,RESERVED_POINTX
		MOV	DX,RESERVED_POINTY
		MOV	AH,RESERVED_STATUS
		AND	AH,100B
		MOV	AL,RESERVED_STATUS
		AND	AL,110000B
		AND	STATUS_BYTE,11001111B
		OR	STATUS_BYTE,AL
		CALL	WRITE_2_BIT
		RET
MAKE_END_POINT	ENDP

;  IN:	ah: next step y is changed
;	bx,dx:	point X,Y
;	status_byte	 if the point is not in seg. then change status only
; change: ax,cx,status_byte
;			constant	 status
TABLE_BUFFER	DB	0000B,0001B    ; 00000000,00000001
		DB	0010B,0011B    ; 00000010,00000011
		DB	0000B,0001B    ; 00000100,00000101
		DB	0010B,0011B    ; 00000110,00000111
		DB	0010B,0011B    ; 00001000,00001001
		DB	1010B,0010B    ; 00001010,00001011
		DB	0010B,0011B    ; 00001100,00001101
		DB	1010B,0010B    ; 00001110,00001111
		DB	0000B,0001B    ; 00010000,00010001
		DB	0010B,0011B    ; 00010010,00010011
		DB	0001B,0101B    ; 00010100,00010101
		DB	0011B,0001B    ; 00010110,00010111
		DB	0010B,0011B    ; 00011000,00011001
		DB	1010B,0010B    ; 00011010,00011011
		DB	0011B,0001B    ; 00011100,00011101
		DB	0010B,0011B    ; 00011110,00011111
		DB	0001B,0101B    ; 00100000,00100001 ?
		DB	0011B,0001B    ; 00100010,00100011 ?
		DB	0000B,0001B    ; 00100100,00100101
		DB	0010B,0011B    ; 00100110,00100111
		DB	0000B,0001B    ; 00101000,00101001
		DB	0010B,0011B    ; 00101010,00101011
		DB	0010B,0011B    ; 00101100,00101101
		DB	1010B,0010B    ; 00101110,00101111
		DB	0001B,0101B    ; 00110000,00110001
		DB	0011B,0001B    ; 00110010,00110011
		DB	0001B,0101B    ; 00110100,00110101
		DB	0011B,0001B    ; 00110110,00110111
		DB	0011B,0001B    ; 00111000,00111001
		DB	0010B,0011B    ; 00111010,00111011
		DB	0011B,0001B    ; 00111100,00111101
		DB	0010B,0011B    ; 00111110,00111111
		DB	0000B,0001B    ; 01000000,01000001
		DB	0010B,0011B    ; 01000010,01000011
		DB	0000B,0001B    ; 01000100,01000101
		DB	0010B,0011B    ; 01000110,01000111
		DB	0000B,0001B    ; 01001000,01001001
		DB	0010B,0011B    ; 01001010,01001011
		DB	0000B,0001B    ; 01001100,01001101
		DB	0010B,0011B    ; 01001110,01001111
		DB	0000B,0001B    ; 01010000,01010001
		DB	0010B,0011B    ; 01010010,01010011
		DB	0001B,0101B    ; 01010100,01010101
		DB	0011B,0001B    ; 01010110,01010111
		DB	0000B,0001B    ; 01011000,01011001
		DB	0010B,0011B    ; 01011010,01011011
		DB	0001B,0101B    ; 01011100,01011101
		DB	0011B,0001B    ; 01011110,01011111
		DB	0001B,0101B    ; 01100000,01100001
		DB	0011B,0001B    ; 01100010,01100011
		DB	0011B,0001B    ; 01100100,01100101
		DB	0010B,0011B    ; 01100110,01100111
		DB	0001B,0101B    ; 01101000,01101001
		DB	0011B,0001B    ; 01101010,01101011
		DB	0011B,0001B    ; 01101100,01101101
		DB	0010B,0011B    ; 01101110,01101111
		DB	0001B,0101B    ; 01110000,01110001
		DB	0011B,0001B    ; 01110010,01110011
		DB	0001B,0101B    ; 01110100,01110101
		DB	0011B,0001B    ; 01110110,01110111
		DB	0001B,0101B    ; 01111000,01111001
		DB	0011B,0001B    ; 01111010,01111011
		DB	0001B,0101B    ; 01111100,01111101
		DB	0011B,0001B    ; 01111110,01111111
		DB	0010B,0011B    ; 10000000,10000001
		DB	1010B,0010B    ; 10000010,10000011
		DB	0010B,0011B    ; 10000100,10000101
		DB	1010B,0010B    ; 10000110,10000111
		DB	0010B,0011B    ; 10001000,10001001
		DB	1010B,0010B    ; 10001010,10001011
		DB	0010B,0011B    ; 10001100,10001101
		DB	1010B,0010B    ; 10001110,10001111
		DB	0010B,0011B    ; 10010000,10010001
		DB	1010B,0010B    ; 10010010,10010011
		DB	0011B,0001B    ; 10010100,10010101
		DB	0010B,0011B    ; 10010110,10010111
		DB	0010B,0011B    ; 10011000,10011001
		DB	1010B,0010B    ; 10011010,10011011
		DB	0011B,0001B    ; 10011100,10011101
		DB	0010B,0011B    ; 10011110,10011111
		DB	0000B,0001B    ; 10100000,10100001
		DB	0010B,0011B    ; 10100010,00100011
		DB	0010B,0011B    ; 10100100,10100101
		DB	1010B,0010B    ; 10100110,10100111
		DB	0000B,0001B    ; 10101000,10101001
		DB	0010B,0011B    ; 10101010,10101011
		DB	0010B,0011B    ; 10101100,10101101
		DB	1010B,0010B    ; 10101110,10101111
		DB	0000B,0001B    ; 10110000,10110001
		DB	0010B,0011B    ; 10110010,10110011
		DB	0000B,0001B    ; 10110100,10110101
		DB	0010B,0011B    ; 10110110,10110111
		DB	0000B,0001B    ; 10111000,10111001
		DB	0010B,0011B    ; 10111010,10111011
		DB	0000B,0001B    ; 10111100,10111101
		DB	0010B,0011B    ; 10111110,10111111
		DB	0010B,0011B    ; 11000000,11000001
		DB	1010B,0010B    ; 11000010,11000011
		DB	0010B,0011B    ; 11000100,11000101
		DB	1010B,0010B    ; 11000110,11000111
		DB	0011B,0001B    ; 11001000,11001001
		DB	0010B,0011B    ; 11001010,11001011
		DB	0011B,0001B    ; 11001100,11001101
		DB	0010B,0011B    ; 11001110,11001111
		DB	0010B,0011B    ; 11010000,11010001 ?
		DB	1010B,0010B    ; 11010010,11010011 ?
		DB	0000B,0001B    ; 11010100,11010101
		DB	0010B,0011B    ; 11010110,11010111
		DB	0000B,0001B    ; 11011000,11011001
		DB	0010B,0011B    ; 11011010,11011011
		DB	0001B,0101B    ; 11011100,11011101
		DB	0011B,0001B    ; 11011110,11011111
		DB	0000B,0001B    ; 11100000,11100001
		DB	0010B,0011B    ; 11100010,11100011
		DB	0010B,0011B    ; 11100100,11100101
		DB	1010B,0010B    ; 11100110,11100111
		DB	0001B,0101B    ; 11101000,11101001
		DB	0011B,0001B    ; 11101010,11101011
		DB	0011B,0001B    ; 11101100,11101101
		DB	0010B,0011B    ; 11101110,11101111
		DB	0000B,0001B    ; 11110000,11110001
		DB	0010B,0011B    ; 11110010,11110011
		DB	0000B,0001B    ; 11110100,11110101
		DB	0010B,0011B    ; 11110110,11110111
		DB	0001B,0101B    ; 11111000,11111001
		DB	0011B,0001B    ; 11111010,11111011
		DB	0001B,0101B    ; 11111100,11111101
		DB	0011B,0001B    ; 11111110,11111111

WRITE_2_BIT	PROC	NEAR
		PUSH	BX
		PUSH	DX
		SUB	DX,START_LINE
		JS	WR
		CMP	DX,LPS
		JNB	WR
		PUSH	AX
		MOV	AX,DX
		MUL	WORD_WIDTH
		SHL	AX,1
		MOV	CX,BX
		AND	CX,11B
		SHR	BX,1
		SHR	BX,1
		ADD	AX,BX
		SHL	CX,1
		MOV	BX,AX
		POP	AX
		MOV	AL,D_BUF1[BX]
		SHL	AL,CL
		AND	AL,11000000B
		ROL	AL,1
		ROL	AL,1
		OR	AL,AH
		CALL	CHANGE_STATUS
		PUSH	BX
		XOR	BH,BH
		MOV	BL,STATUS_BYTE
		MOV	AL,TABLE_BUFFER[BX]
		POP	BX
		TEST	AL,11B
		JZ	WR1
		TEST	AL,100B      ; WRITE 01 ON RIGHT
		JNZ	WB1
		TEST	AL,1000B     ; WRITE 10 ON LEFT
		JNZ	WB2
WB0:
		CALL	NORMAL_WRITE
WR1:
		POP	DX
		POP	BX
		RET
WR:
		MOV	AL,AH
		CALL	CHANGE_STATUS
		POP	DX
		POP	BX
		RET
WB1:
		PUSH	CX
		PUSH	BX
		PUSH	AX
		INC	CL
		INC	CL
		CMP	CL,8
		JNZ	WB3
		MOV	CL,0
		INC	BX
WB3:
		MOV	AL,01B
		CALL	RIGHT_WRITE
		POP	AX
		POP	BX
		POP	CX
		JMP	WB0
WB2:
		PUSH	CX
		PUSH	BX
		PUSH	AX
		DEC	CL
		DEC	CL
		JNS	WB4
		MOV	CL,6
		DEC	BX
WB4:
		MOV	AL,10B
		CALL	LEFT_WRITE
		POP	AX
		POP	BX
		POP	CX
		JMP	WB0
WRITE_2_BIT	ENDP


; IN:  bx:  offset of two bit buffer
;      cl:  number of bit move
;      al:  bit 0,1 (01) write to buffer
RW_ENTER	DW	OFFSET RW0011
		DW	OFFSET RW01
		DW	OFFSET RW10
		DW	OFFSET RW0011

RIGHT_WRITE	PROC	NEAR
		PUSH	CX
		PUSH	BX
		PUSH	AX
		MOV	AL,D_BUF1[BX]
		SHL	AL,CL
		AND	AL,11000000B
		ROL	AL,1
		ROL	AL,1
		PUSH	BX
		XOR	BH,BH
		MOV	BL,AL
		SHL	BX,1
		JMP	RW_ENTER[BX]
RW0011:
		MOV	AL,01B
RW1:
		POP	BX
		CALL	NORMAL_WRITE
		JMP	SHORT RW_RETURN
RW10:
		MOV	AL,11B
		JMP	SHORT RW1
RW01:
		POP	BX
		INC	CL
		INC	CL
		CMP	CL,8
		JNZ	RW2
		MOV	CL,0
		INC	BX
RW2:
		CALL	RIGHT_WRITE
RW_RETURN:
		POP	AX
		POP	BX
		POP	CX
		RET
RIGHT_WRITE	ENDP

; IN:  bx:  offset of two bit buffer
;      cl:  number of bit move
;      al:  bit 0,1 (10) write to buffer
LW_ENTER	DW	OFFSET LW0011
		DW	OFFSET LW01
		DW	OFFSET LW10
		DW	OFFSET LW0011

LEFT_WRITE	PROC	NEAR
		PUSH	CX
		PUSH	BX
		PUSH	AX
		MOV	AL,D_BUF1[BX]
		SHL	AL,CL
		AND	AL,11000000B
		ROL	AL,1
		ROL	AL,1
		PUSH	BX
		XOR	BH,BH
		MOV	BL,AL
		SHL	BX,1
		JMP	LW_ENTER[BX]
LW0011:
		MOV	AL,10B
LW1:
		POP	BX
		CALL	NORMAL_WRITE
		JMP	RW_RETURN
LW01:
		MOV	AL,11B
		JMP	SHORT LW1
LW10:
		POP	BX
		DEC	CL
		DEC	CL
		JNS	LW2
		MOV	CL,6
		DEC	BX
LW2:
		CALL	LEFT_WRITE
LW_RETURN:
		POP	AX
		POP	BX
		POP	CX
		RET
LEFT_WRITE	ENDP

; IN:  al: bit 2 this step changed or not
CHANGE_STATUS	PROC	NEAR
		MOV	AH,STATUS_BYTE
		AND	AH,100B
		SHL	AH,1
		OR	AL,AH
		AND	STATUS_BYTE,11110000B
		OR	STATUS_BYTE,AL
		RET
CHANGE_STATUS	ENDP

; IN: al:  bit 0,1   write in buffer
;     bx:  offset in buffer
NORMAL_WRITE	PROC	NEAR
		MOV	AH,AL
		MOV	AL,D_BUF1[BX]
		ROL	AL,CL
		SHL	AL,1
		SHL	AL,1
		SHR	AX,1
		SHR	AX,1
		ROR	AL,CL
		MOV	D_BUF1[BX],AL
		RET
NORMAL_WRITE	ENDP

;  IN:	two_bit_buffer
;	dot_buffer
;	lps
;	word_width
; Change: ah,al:  two bit mark	    cx: count of dot
;	     dx:  count of line     si: two bit mark offset
;	     di:  dot mark offset   bp: count of level
;	     bx:  dot type enter offset
DT_ENTER	DW	OFFSET DT00
		DW	OFFSET DT01
		DW	OFFSET DT10
		DW	OFFSET DT11

CHANGE_TO_DOT	PROC	NEAR
		XOR	AX,AX
		XOR	BX,BX
		MOV	SI,OFFSET D_BUF1
		MOV	DI,OFFSET D_BUF2
		MOV	DX,LPS
CT0:
		XOR	BP,BP
		MOV	CX,WORD_WIDTH
CT1:
		PUSH	CX
		MOV	CX,2
CT2:
		PUSH	CX
		MOV	CX,4
		MOV	AL,[SI]
CT3:
		SHL	AX,1
		SHL	AX,1
		MOV	BL,AH
		SHL	BX,1
		JMP	DT_ENTER[BX]
DT00:
		CMP	BP,0
		JNZ	CT4
		CLC
		JMP	SHORT EXIT
CT4:
		STC
		JMP	SHORT EXIT
DT01:
		INC	BP
		STC
		JMP	SHORT EXIT
DT10:
		DEC	BP
DT11:
		STC
EXIT:
		RCL	BYTE PTR [DI],1
		XOR	AH,AH
		LOOP	CT3
		POP	CX
		INC	SI
		LOOP	CT2
		POP	CX
		INC	DI
		LOOP	CT1
		DEC	DX
		JNZ	CT0
		RET
CHANGE_TO_DOT	ENDP

D_BUF1		DB	(WORD_SIZE/4)*FIX_LPS DUP (0)
D_BUF2		DB	(WORD_SIZE/8)*FIX_LPS DUP (0)
D_BUF3		DB	2500 DUP(0)			;		10.30

;READSL----------------------------------------------------------------------
;入口参数:
;	ax	字符号
;	bx	字库号
;	two_bit_buffer	 矢量码缓冲
;返回参数:
;	CN	成功
;	CY	失败
;子程序:按字库号及字符顺序号读取字符矢量码
READZK		PROC	NEAR
		CMP	AX,IDX_MAX
		JB	RZ_1
		MOV	AX,IDX_MAX
RZ_1:
		PUSH	AX
		PUSH	BX
		PUSH	CX
		PUSH	DX
		CALL	S_OPEN
		MOV	CX,6
		MUL	CX
		CALL	READFILE
		JB	RZ_4
		MOV	CX,WORD PTR D_BUF1+4
		OR	CX,CX			;12.7
		JZ	RZ_4
		MOV	SLIP_LEN,CX
		MOV	DX,WORD PTR D_BUF1+2
		MOV	AX,WORD PTR D_BUF1
		CALL	READFILE
		JC	RZ_4
		MOV	SI,OFFSET D_BUF1
		MOV	DI,OFFSET D_BUF2
		CMP	FNUM,27
		JB	RZ_2
		MOV	CX,SLIP_LEN
		DEC	SLIP_LEN
		DEC	SLIP_LEN
		REP	MOVSW
		JMP	SHORT RZ_3
RZ_2:
		CALL	MELTE
RZ_3:
		CALL	S_CLOSE
		CLC
		JMP	SHORT RZ_5
RZ_4:
		CALL	S_CLOSE 		;			10.29
		STC
RZ_5:
		POP	DX
		POP	CX
		POP	BX
		POP	AX
		RET
READZK		ENDP

D_PSP		DW	0			;原PSP			10.29
;子程序:打开文件
S_OPEN		PROC	NEAR
		CMP	K_W,'W'
		JNZ	L_O2
		PUSH	AX
		MOV	AX,9			;每文件名9字节
		MUL	BX
		ADD	AX,D_HZKSL		;OFFSET FH_T
		MOV	SI,AX			;指定字库文件名
		MOV	DI,SET_NAME
		MOV	CX,9
		REP	MOVSB			;复制文件名

		MOV	AH,62H			;取原PSP		10.29
		INT	21H
		MOV	D_PSP,BX
		MOV	DX,OFFSET SET_PATH
		MOV	AX,3D00H		;打开文件
		INT	21H
		JB	L_O1
		MOV	BX,AX
		MOV	D_HANDLE,AX
		CLC
L_O1:
		POP	AX
L_O2:
		RET
S_OPEN		ENDP

;子程序:关闭文件
S_CLOSE 	PROC	NEAR
		CMP	K_W,'W'
		JNZ	L_CLO1
		MOV	BX,D_HANDLE
		MOV	AH,3EH			;关闭
		INT	21H
		MOV	BX,D_PSP
		MOV	AH,51H			;恢复原PSP		10.29
		INT	21H
L_CLO1:
		RET
S_CLOSE 	ENDP

;子程序:读文件 BX=文件号,DX:AX=字库偏移,D_BUF1,CX=字节数
READFILE	PROC	NEAR
		CMP	K_W,'W'
		JNZ	READBLOCK
		PUSH	CX
		MOV	CX,DX
		MOV	DX,AX
		MOV	AX,4200H		;移动读写指针
		INT	21H
		POP	CX
		MOV	DX,OFFSET D_BUF1
		MOV	AH,3FH			;读文件
		INT	21H
		RET
READFILE	ENDP
K_READSLW	EQU	$

FONTLEN 	DW	0			;每字字节数
CURRSECTOR	DW	0			;当前扇区号
CURRFONT	DW	0			;当前库
SECTORLEN	DW	0			;扇区字节数
SECTORSPERTRACK DW	0			;每道扇区数
HEADS		DW	0			;磁头数
D_0225		DB	2			;当前盘号
D_0226		DW	0			;分区首扇区号
D_0228		DW	0			;      磁柱号

;入口参数:
;	BX=字库号,DX:AX=字库偏移,two_bit_buffer,CX=字节数
READBLOCK	PROC	NEAR
		PUSH	BX
		SHL	BX,1
		MOV	BX,DH_T[BX]
		OR	BX,BX
		POP	BX
		JNZ	RB_1
		STC
		RET
RB_1:
		MOV	DI,OFFSET D_BUF1
		CLD
		PUSH	AX
		PUSH	BX
		PUSH	CX
		PUSH	DX
		PUSH	SI
		PUSH	DI
		MOV	FONTLEN,CX
		DIV	SECTORLEN		;扇区字节数
		PUSH	DX

		MOV	CURRSECTOR,AX		;当前扇区号
		SHL	BX,1
		MOV	BX,DH_T[BX]
		MOV	CURRFONT,BX		;当前库
		CALL	READSECTOR		;读扇区

		POP	SI
		MOV	CX,SECTORLEN		;扇区字节数
		SUB	CX,SI

RB_2:		CMP	CX,FONTLEN		;比每字字节数
		JBE	RB_3
		MOV	CX,FONTLEN
RB_3:		SUB	FONTLEN,CX
		REP	MOVSB

		CMP	FONTLEN,0		;每字字节数
		JZ	RB_4
		PUSH	DI
		INC	CURRSECTOR
		MOV	AX,CURRSECTOR		;当前扇区号
		CALL	READSECTOR		;读扇区
		POP	DI
		XOR	SI,SI
		MOV	CX,SECTORLEN
		JMP	SHORT RB_2
RB_4:
		POP	DI
		POP	SI
		POP	DX
		POP	CX
		POP	BX
		POP	AX
		CLC
		RET
READBLOCK	ENDP

;子程序:读扇区
READSECTOR	PROC	NEAR
		MOV	BX,CURRFONT		  ;当前库
RS_1:
		CMP	AX,[BX+4]
		JB	RS_2
		SUB	AX,[BX+4]
		ADD	BX,6
		JMP	SHORT RS_1
RS_2:
		MOV	DX,[BX+2]
		ADD	AX,[BX]
		ADC	DX,0
		DIV	SECTORSPERTRACK 	  ;每道扇区数
		ADD	DX,D_0226		;加分区首扇区号
		CMP	DX,SECTORSPERTRACK
		JBE	RS_3
		MOV	DX,1
		INC	AX
RS_3:
		MOV	CL,DL
		XOR	DX,DX
		DIV	HEADS			  ;磁头数
		MOV	DH,DL
		ADD	AX,D_0228		;加分区首磁柱号
		MOV	CH,AL
		MOV	AL,40H
		MUL	AH
		ADD	CL,AL
		MOV	DL,80H			  ;物理C盘
		XOR	BX,BX
		MOV	AX,201H 		  ;读一个扇区
		INT	13H
		RET
READSECTOR	ENDP

;----------------------------------------------------------------------------
D_BUFF		DB	1024 DUP (0)

;****************************************************************************
BEGIN:
		MOV	AX,357EH
		INT	21H
		CMP	WORD PTR ES:[BX-2],'LS' ;判驻留?
		JNZ	L_S10
		MOV	DX,OFFSET ALREADY
		MOV	AH,9
		INT	21H
		INT	20H
L_S10:
		PUSH	CS
		POP	ES

		MOV	SI,5DH
		MOV	AX,CS
		CMP	AX,0A000H		;判LH
		JB	L_S12
		MOV	SI,6DH
L_S12:
		LODSB
		AND	AL,5FH
		MOV	K_W,AL			;保存

		MOV	AH,19H			;取当前盘
		INT	21H
		ADD	CUR_DRIVE,AL
		MOV	FCB_DRIVE,AL
		INC	AL
		MOV	DL,AL
		MOV	SI,OFFSET CUR_PATH
		MOV	AH,47H			;取当前路径
		INT	21H

		CALL	S_GETPATH		;取本程序路径

		MOV	DI,OFFSET SET_PATH
		MOV	DL,[DI]
		AND	DL,5FH
		SUB	DL,'A'

		CMP	DL,1
		JA	L_S26
L_S24:
		MOV	DX,OFFSET NOPATH
		MOV	AH,9
		INT	21H
L_ERR:
		CALL	S_HF			;恢复当前盘及路径
		INT	20H
L_S26:
		MOV	AH,0EH			;置当前盘
		INT	21H
L_S28:
		MOV	DX,DI
		MOV	AH,3BH			;置字库路径
		INT	21H
		JB	L_S24

		CMP	K_W,'W'                 ;判文件方式?
		JNZ	L_S50
		MOV	SI,SET_NAME
		MOV	BYTE PTR [SI-1],'\'     ;原为0

		MOV	SI,OFFSET FH_T		;字库文件名表
		MOV	DI,D_HZKSL		;=88H
		MOV	CX,OFFSET FH_END
		SUB	CX,SI
		REP	MOVSB			;传送

		MOV	DX,D_HZKSL		;文件名表
		MOV	DI,OFFSET DH_T		;字库有无(=1有)
		MOV	BP,35
L_S40:
		MOV	AX,4300H		;取文件属性
		INT	21H
		MOV	AX,1
		JNB	L_S41
		DEC	AX
L_S41:
		STOSW
		ADD	DX,9
		DEC	BP
		JNZ	L_S40

		MOV	BP,OFFSET K_READSLW
		JMP	L_S100
L_S50:
		MOV	AH,19H			;取当前盘
		INT	21H
		MOV	D_0225,AL		;当前盘号
		INC	AL
		MOV	F_DRIVE,AL

		MOV	AX,201H
		MOV	BX,OFFSET D_SEC
		MOV	CX,1
		MOV	DX,80H
		PUSH	CX
		INT	13H			;读C盘总引导区
		POP	CX

		DEC	D_0225
L_S52:
		DEC	D_0225
		JZ	L_S54
		CALL	READBOOT		;读下一分区BOOT
		JMP	SHORT L_S52
L_S54:
		PUSH	CX
		MOV	DL,CH			;磁柱号低8位
		XOR	CH,CH
		SHL	CX,1			;磁柱号高2位移CH
		SHL	CX,1
		MOV	DH,CH
		POP	CX
		AND	CX,3FH
		MOV	D_0226,CX		;分区首扇区号
		MOV	D_0228,DX		;      磁柱号

		MOV	SI,1BEH
L_S56:
		MOV	AL,DS:[BX+SI+4]
		CMP	AL,1			;判12位FAT DOS分区
		JZ	L_S58
		CMP	AL,4			;判16位FAT DOS分区
		JZ	L_S58
		CMP	AL,6			;判大硬盘DOS分区
		JZ	L_S58
		ADD	SI,10H
		JMP	SHORT L_S56
L_S58:
		MOV	D_DOS,AL
		MOV	DH,[BX+SI+1]
		MOV	CX,[BX+SI+2]
		MOV	DL,80H
		MOV	AX,201H
		PUSH	CX
		INT	13H			;读DOS引导扇区
		POP	CX

		PUSH	DX
		MOV	AX,[BX+0BH]		;扇区字节数
		MOV	SECTORLEN,AX
		MOV	AX,[BX+18H]		;每道扇区数
		MOV	SECTORSPERTRACK,AX
		MOV	AX,[BX+1AH]		;磁头数
		MOV	HEADS,AX
		MOV	AL,[BX+0DH]		;每簇扇区数
		XOR	AH,AH
		MOV	DS:[0F0H],AX
		MOV	AX,[BX+16H]		;FAT扇区数
		MUL	BYTE PTR [BX+10H]	;*FAT个数
		ADD	AX,[BX+0EH]		;+保留扇区数
		ADD	AX,[BX+1CH]		;+隐含扇区数
		MOV	DS:[0F4H],AX		;目录区开始逻辑扇区号
		MOV	AX,20H
		MUL	WORD PTR [BX+11H]	;根目录项数
		DIV	SECTORLEN		;除扇区字节数
		ADD	DS:[0F4H],AX		;文件区开始逻辑扇区号
		POP	DX

		MOV	AX,CS
		CMP	AX,0A000H		;判UMB?
		JB	L_S62
		PUSH	BX
		MOV	AH,52H			;取DOS内部表
		INT	21H
		MOV	AX,ES:[BX-2]		;内存链首
		POP	BX
L_S60:
		MOV	ES,AX
		INC	AX
		ADD	AX,ES:[3]		;第一自由块
		CMP	AX,7000H
		JB	L_S60
		SUB	AX,ES:[3]
L_S62:
		ADD	AX,1000H		;下64K
		MOV	DS:[0F8H],AX		;第一FAT段
		MOV	ES,AX
		ADD	AX,1000H
		MOV	DS:[0FAH],AX		;第二FAT段

		MOV	AX,[BX+16H]		;FAT扇区数	4.8
		PUSH	AX
		CMP	AX,80H			;		4.8
		JBE	L_S64
		MOV	AL,80H
L_S64:
		XOR	BX,BX
		INC	CX
		MOV	AH,2
		PUSH	CX
		INT	13H			;读第一FAT表
		POP	CX
		ADD	CL,80H
		MOV	AL,CL
		XOR	AH,AH
		DIV	BYTE PTR SECTORSPERTRACK	 ;每道扇区数
		MOV	CL,AH
		ADD	AL,DH
		XOR	AH,AH
		DIV	BYTE PTR HEADS		;磁头数
		MOV	DH,AH
		ADD	CH,AL

		POP	AX
		CMP	AX,80H			;FAT表>64K?	4.8
		JBE	L_S70
		SUB	AX,80H			;		4.8
		MOV	ES,DS:[0FAH]
		XOR	BX,BX
		MOV	AH,2			;读第二FAT表
		INT	13H
L_S70:
		MOV	ES,DS:[0F8H]		;指向第一FAT首
		MOV	BP,OFFSET D_BUFF	;指连续块表
		MOV	DX,OFFSET FCB_T 	;第一个字库文件
		XOR	CX,CX			;字库计数
L_S72:
		MOV	AL,F_DRIVE
		MOV	DI,DX
		MOV	[DI],AL
		PUSH	DX
		PUSH	CX
		CALL	PROCESSFILE		;处理
		OR	AX,AX
		JZ	L_S74
		INC	NOFILEC
L_S74:
		POP	CX
		POP	DX
		MOV	BX,CX
		SHL	BX,1
		MOV	DH_T[BX],AX		;存本字库连续块表地址
		ADD	DX,37			;下一字库文件名
		INC	CX
		CMP	CX,FONTNUMBER
		JBE	L_S72
	;	MOV	BP,AX

		CMP	NOFILEC,0		;判无矢量字库?
		JNZ	L_S100
		JMP	L_ERR			;			8.20
L_S100:
		MOV	AX,CS
		CMP	AX,0A000H		;判LH?
		JA	L_S130
		MOV	SI,80H
		LODSB
		OR	AL,AL
		JZ	L_S120
L_S110:
		LODSB
		CMP	AL,0DH
		JZ	L_S120
		CMP	AL,'/'
		JNZ	L_S110
		LODSB
		AND	AL,5FH
		CMP	AL,'N'                  ;/N:驻留基本内存
		JNZ	L_S110
		JMP	SHORT L_S130
L_S120:
		CALL	S_GETUMB		;分配UMB段
		JZ	L_S140
L_S130:
		MOV	ES,DS:[2CH]
		MOV	AH,49H			;清环境块
		INT	21H
		CALL	S_SETINT
		MOV	DX,BP			;驻留
		INT	27H
L_S140:
		MOV	AX,D_UMB
		OR	AX,AX
		JZ	L_S130
		DEC	AX
		MOV	ES,AX
		MOV	DI,8
		MOV	SI,OFFSET D_NAME
		MOV	CX,7
		REP	MOVSB			;向UMB文件控制块写入本模块名

		MOV	ES,D_UMB		;段
		XOR	SI,SI
		MOV	DI,SI
		MOV	CX,BP
		REP	MOVSB			;拷贝本模块到UMB
		PUSH	ES
		POP	DS

		CALL	S_SETINT

		PUSH	CS
		POP	DS
		MOV	ES,DS:[2CH]
		MOV	AH,49H			;清环境块
		INT	21H
		PUSH	CS
		POP	ES
		MOV	AH,49H			;清本模块
		INT	21H

		MOV	AH,50H			;设置新PSP
		MOV	BX,D_UMB
		INT	21H
		MOV	DX,D_LEN		;本模块长度(节)
		MOV	AX,3100H		;驻留
		INT	21H

F_DRIVE 	DB	1
FCB_DRIVE	DB	1
CUR_DRIVE	DB	'A:\'
CUR_PATH	DB	64 DUP(0)
NOFILEC 	DB	0

D_XMS		DD	0			;XMS驱动地址
D_NCFP		DW	0			;原内存分配策略
D_UMB0		DW	0			;原UMB连接状态
D_UMB		DW	0			;分配UMB段
D_LEN		DW	0			;本模块长度(节)

;子程序:取UMB段
S_GETUMB	PROC	NEAR
		CALL	S_GETXMS		;取XMS驱动地址
		JNZ	L_GU2
		MOV	AX,BP
		MOV	CL,4
		SHR	AX,CL
		INC	AX
		MOV	D_LEN,AX		;本模块驻留长度(节)

		MOV	AH,10H			;请求UMB
		CALL	D_XMS			;XMS
		CMP	AX,1			;=1:成功,BX=段
		JZ	L_GU1
		CALL	S_UMB			;分配UMB段BX
		CMP	AL,AL			;ZF=1
		RET
L_GU1:
		MOV	D_UMB,BX		;取出UMB段
L_GU2:
		RET
S_GETUMB	ENDP

S_UMB		PROC	NEAR
		MOV	AX,3000H		;取DOS版本号
		INT	21H
		CMP	AL,5			;判>5.0
		JB	L_UMB3
		MOV	AX,5800H		;取内存分配策略AX
		INT	21H
		MOV	D_NCFP,AX
		MOV	AX,5802H		;取UMB连接状态AL
		INT	21H
		CBW
		MOV	D_UMB0,AX

		MOV	AX,5803H		;置UMB连接
		MOV	BX,1			;=1连接
		INT	21H
		JC	L_UMB3
		MOV	AX,5801H		;置内存分配策略
		MOV	BX,41H			;最佳适合块
		INT	21H
		JC	L_UMB2
		MOV	AH,48H			;分配内存
		MOV	BX,D_LEN
		INT	21H
		JC	L_UMB1
		MOV	D_UMB,AX		;分配块段
L_UMB1:
		MOV	AX,5801H		;恢复内存分配策略
		MOV	BX,D_NCFP
		INT	21H
L_UMB2:
		MOV	BX,D_UMB0
		MOV	AX,5803H		;恢复UMB连接状态
		INT	21H
L_UMB3:
		RET
S_UMB		ENDP

;子程序:取XMS驱动地址 ->D_XMS
S_GETXMS	PROC	NEAR
		MOV	AX,4300H		;取XMS安装状态
		INT	2FH
		CMP	AL,80H			;=80H:已安装
		JNZ	L_GX1
		MOV	AX,4310H		;取XMS驱动地址
		INT	2FH
		MOV	WORD PTR D_XMS,BX	;保存
		MOV	WORD PTR D_XMS+2,ES
		CMP	AL,AL			;返回ZF=1
L_GX1:
		RET
S_GETXMS	ENDP

S_SETINT	PROC	NEAR
		MOV	DX,OFFSET INT_7E
		MOV	AX,257EH		;建中断
		INT	21H
		CALL	S_HF			;恢复当前盘及路径
		RET
S_SETINT	ENDP

;〖子程序:恢复当前盘及路径〗
S_HF		PROC	NEAR
		PUSH	CS
		POP	DS
		MOV	DL,FCB_DRIVE
		MOV	AH,0EH			;置当前盘
		INT	21H
		MOV	DX,OFFSET CUR_DRIVE
		MOV	AH,3BH			;置当前路径
		INT	21H
		RET
S_HF		ENDP

;READSL用--------------------------------------------------------------------
FCB_T		DB	3,'HZKSLT     ',25 DUP(0)
FCB_S		DB	3,'HZKSLSTJ   ',25 DUP(0)
FCB_F		DB	3,'HZKSLFSJ   ',25 DUP(0)
FCB_H		DB	3,'HZKSLHTJ   ',25 DUP(0)
FCB_K		DB	3,'HZKSLKTJ   ',25 DUP(0)
FCB_XBJ 	DB	3,'HZKSLXBJ   ',25 DUP(0)
FCB_BSJ 	DB	3,'           ',25 DUP(0)
FCB_Y1J 	DB	3,'HZKSLY1J   ',25 DUP(0)
FCB_Y3J 	DB	3,'HZKSLY3J   ',25 DUP(0)
FCB_LBJ 	DB	3,'HZKSLLBJ   ',25 DUP(0)
FCB_DHJ 	DB	3,'HZKSLDHJ   ',25 DUP(0)
FCB_WBJ 	DB	3,'HZKSLWBJ   ',25 DUP(0)
FCB_XKJ 	DB	3,'HZKSLXKJ   ',25 DUP(0)
FCB_LSJ 	DB	3,'HZKSLLSJ   ',25 DUP(0)
FCB_YTJ 	DB	3,'HZKSLYTJ   ',25 DUP(0)
FCB_MHJ 	DB	3,'HZKSLMHJ   ',25 DUP(0)

FCB_1		DB	3,'           ',25 DUP(0)
FCB_2		DB	3,'           ',25 DUP(0)
FCB_3		DB	3,'           ',25 DUP(0)
FCB_4		DB	3,'           ',25 DUP(0)
FCB_5		DB	3,'           ',25 DUP(0)

FCB_STF 	DB	3,'HZKSLSTF   ',25 DUP(0)
FCB_FSF 	DB	3,'HZKSLFSF   ',25 DUP(0)
FCB_HTF 	DB	3,'HZKSLHTF   ',25 DUP(0)
FCB_KTF 	DB	3,'HZKSLKTF   ',25 DUP(0)
FCB_XBF 	DB	3,'           ',25 DUP(0)
FCB_XLF 	DB	3,'           ',25 DUP(0)
FCB_Y1F 	DB	3,'HZKSLY1F   ',25 DUP(0)
FCB_Y3F 	DB	3,'HZKSLY3F   ',25 DUP(0)
FCB_LBF 	DB	3,'HZKSLLBF   ',25 DUP(0)
FCB_DHF 	DB	3,'HZKSLDHF   ',25 DUP(0)
FCB_WBF 	DB	3,'HZKSLWBF   ',25 DUP(0)
FCB_XKF 	DB	3,'HZKSLXKF   ',25 DUP(0)
FCB_HPF 	DB	3,'HZKSLHPF   ',25 DUP(0)
FCB_ZYF 	DB	3,'HZKSLZYF   ',25 DUP(0)

D_DOS		DB	0	;DOS分区标志

;子程序:建立各字库文件连续块表 返回:AX=0无字库,非0:本字库表项开始地址
PROCESSFILE	PROC	NEAR
		MOV	SI,BP			;连续块表本字库项地址
		PUSH	DX
		MOV	DX,90H			;			11.27
		MOV	DI,DX
		MOV	AH,1AH			;设置DTA地址
		INT	21H
		POP	DX
		MOV	AH,11H			;查找文件
		INT	21H
		OR	AL,AL
		JZ	L_P1
L_P0:
		XOR	AX,AX
		RET
L_P1:
		MOV	AX,[DI+1BH]		;首簇号
L_P1A:
		PUSH	AX
		SUB	AX,2
		MUL	WORD PTR DS:[0F0H]	;*每簇扇区数
		ADD	AX,DS:[0F4H]		;+文件区首扇区号
		ADC	DX,0
		MOV	DS:[BP],AX		;连续块首扇区号
		MOV	DS:[BP+2],DX
		POP	AX
		MOV	WORD PTR DS:[0F6H],0	;连续簇计数清0
L_P2:
		PUSH	AX
		INC	WORD PTR DS:[0F6H]	;计数+1
		MOV	BX,AX
		CMP	D_DOS,1 		;判12位DOS分区?
		JZ	L_P4
		MOV	ES,DS:[0F8H]
		ADD	BX,AX
		JNC	L_P3
		MOV	ES,DS:[0FAH]
L_P3:
		MOV	AX,ES:[BX]
		CMP	AX,0FFF8H
		JMP	SHORT L_P7
L_P4:
		SHR	AX,1
		PUSHF
		ADD	BX,AX
		MOV	AX,ES:[BX]
		POPF
		JNB	L_P5
		MOV	CL,4
		SHR	AX,CL
		JMP	SHORT L_P6
L_P5:
		AND	AX,0FFFH
L_P6:
		CMP	AX,0FF8H
L_P7:
		POP	BX
		JB	L_P8
		MOV	AX,-1
		MOV	DS:[BP+4],AX		;末块标志
		ADD	BP,6
		MOV	AX,SI
		RET
L_P8:
		INC	BX
		CMP	AX,BX			;判连续?
		JZ	L_P2
		PUSH	AX
		MOV	AX,DS:[0F0H]		;每醋扇区数
		MUL	WORD PTR DS:[0F6H]	;*连续簇数
		MOV	DS:[BP+4],AX		;存连续扇区数

		ADD	BP,6
		POP	AX
		JMP	L_P1A
PROCESSFILE	ENDP

;子程序:读下一分区BOOT
READBOOT	PROC	NEAR
		MOV	SI,1BEH 		;分区表首
L_RB1:
		CMP	BYTE PTR [BX+SI+4],5	;判扩展分区
		JZ	L_RB2
		ADD	SI,10H			;转下一分区
		JMP	SHORT L_RB1
L_RB2:
		MOV	CX,[BX+SI+2]
		MOV	DX,[BX+SI]
		OR	DL,80H
		MOV	AX,201H
		INT	13H			;读下一分区BOOT
		RET
READBOOT	ENDP

;READSLW---------------------------------------------------------------------
FH_T		DB	'HZKSLT',0,0,0
FH_S		DB	'HZKSLSTJ',0
FH_F		DB	'HZKSLFSJ',0
FH_H		DB	'HZKSLHTJ',0
FH_K		DB	'HZKSLKTJ',0
FH_XBJ		DB	'HZKSLXBJ',0
FH_BSJ		DB	'HZKSLBSJ',0
FH_Y1J		DB	'HZKSLY1J',0
FH_Y3J		DB	'HZKSLY3J',0
FH_LBJ		DB	'HZKSLLBJ',0
FH_DHJ		DB	'HZKSLDHJ',0
FH_WBJ		DB	'HZKSLWBJ',0
FH_XKJ		DB	'HZKSLXKJ',0
FH_LSJ		DB	'HZKSLLSJ',0
FH_YTJ		DB	'HZKSLYTJ',0
FH_MHJ		DB	'HZKSLMHJ',0

FH_1		DB	'        ',0
FH_2		DB	'        ',0
FH_3		DB	'        ',0
FH_4		DB	'        ',0
FH_5		DB	'        ',0

FH_STF		DB	'HZKSLSTF',0
FH_FSF		DB	'HZKSLFSF',0
FH_HTF		DB	'HZKSLHTF',0
FH_KTF		DB	'HZKSLKTF',0
FH_XBF		DB	'HZKSLXBF',0
FH_XLF		DB	'HZKSLXLF',0
FH_Y1F		DB	'HZKSLY1F',0
FH_Y3F		DB	'HZKSLY3F',0
FH_LBF		DB	'HZKSLLBF',0
FH_DHF		DB	'HZKSLDHF',0
FH_WBF		DB	'HZKSLWBF',0
FH_XKF		DB	'HZKSLXKF',0
FH_HPF		DB	'HZKSLHPF',0
FH_ZYF		DB	'HZKSLZYF',0
FH_END	EQU	$

;本程序用--------------------------------------------------------------------
;子程序:取本程序所在路径
S_GETPATH	PROC	NEAR
		MOV	DS,DS:[2CH]		;环境段
		XOR	SI,SI
L_GP1:
		CMP	WORD PTR DS:[SI],0	;查找环境区尾?
		JZ	L_GP2
		INC	SI
		JMP	SHORT L_GP1
L_GP2:
		ADD	SI,4
		MOV	DI,OFFSET SET_PATH	;带路径源文件名区
		PUSH	CS
		POP	ES
		CMP	BYTE PTR [SI+1],':'     ;判有盘符?
		JZ	L_GP3
		MOV	AH,19H			;取当前盘
		INT	21H
		INC	AL
		MOV	DL,AL
		OR	AL,40H
		STOSB				;写入盘符
		MOV	AL,':'
		STOSB
		CMP	BYTE PTR [SI],'\'       ;判有绝对路径?
		JZ	L_GP3
		MOV	AL,'\'
		STOSB
		JMP	SHORT L_GP4
L_GP3:
		CMP	BYTE PTR [SI+2],'\'     ;判有绝对路径?
		JZ	L_GP5
		LODSW				;盘符和\
		MOV	DL,AL			;盘符
		SUB	DL,40H
		STOSW
L_GP4:
		PUSH	SI
		MOV	SI,DI
		MOV	AH,47H			;取当前路径
		INT	21H
		POP	SI
L_GP5:
		CALL	S_MOVE			;传送
		PUSH	CS
		POP	DS
L_GP6:
		CMP	BYTE PTR [DI],'\'       ;最后一个\
		JZ	L_GP7
		DEC	DI
		JMP	SHORT L_GP6
L_GP7:
		MOV	BYTE PTR [DI],0
		MOV	AX,DI
		INC	AX
		MOV	SET_NAME,AX		;字库文件名写入地址
		RET
S_MOVE:
		LODSB
		STOSB
		OR	AL,AL
		JNZ	S_MOVE
		RET
S_GETPATH	ENDP

D_NAME		DB	'READSL',0
ALREADY 	DB	'本模块已经存在!',13,10,'$'
NOPATH		DB	'字库不在!',7,13,10,'$'

D_SEC	EQU	$

CSEG		ENDS
		END	START
